#!/bin/bash
exec scala -J-mx2g "$0" "$@"
!#

//
// This script converts between the Monarch TSV file sent by Peter Clark to
// a perfcase file used by NaturalLI.
//
// Usage:
//   ./monarch2perfcase <INPUT_TSV> <train|dev|test>
//
//

// (scala)
import scala.collection.JavaConversions._
import scala.collection._
// (corenlp)
import edu.stanford.nlp.simple._
import edu.stanford.nlp.ling.IndexedWord
import edu.stanford.nlp.semgraph.semgrex._

// Semgrex patterns
val SEMGREX_PATTERNS_WHAT_HOW = List(
  (false, SemgrexPattern.compile("{} >/.obj/    ( {}=target ?>amod {}=adj )")),
  (false, SemgrexPattern.compile("{} >/nsubj/ ( ( {}=target ?>amod {}=adj ) >/nmod:poss/ {} )")),
  (true, SemgrexPattern.compile("{} >/nmod:.*/  ( {}=target ?>amod {}=adj )")),
  (false, SemgrexPattern.compile("{} >/nsubj/   ( {}=target ?>amod {}=adj )"))
  )

val SEMGREX_PATTERNS_OTHER = List(
  (false, SemgrexPattern.compile("{} >/nsubj/   ( {}=target ?>amod {}=adj )")),
  (true, SemgrexPattern.compile("{} >/nmod:.*/  ( {}=target ?>amod {}=adj )")),
  (false, SemgrexPattern.compile("{} >/.obj/    ( {}=target ?>amod {}=adj )")),
  (false, SemgrexPattern.compile("{} >/nsubj/ ( ( {}=target ?>amod {}=adj ) >/nmod:poss/ {} )"))
  )

// Regexes for a sentence with 2, 3, or 4 options
val Q2 = """(.*)\(A\)(.*?)\.?\s*\(B\)(.*?)\.?\s*""".r
val Q3 = """(.*)\(A\)(.*?)\.?\s*\(B\)(.*?)\.?\s*\(C\)(.*?)\.?\s*""".r
val Q4 = """(.*)\(A\)(.*?)\.?\s*\(B\)(.*?)\.?\s*\(C\)(.*?)\.?\s*\(D\)(.*?)\.?\s*""".r

var multiSentencePremises:Int = 0
var allQuestions:Int = 0

// Grok input file
for (line <- scala.io.Source.fromFile(args(0)).getLines.toList.tail) {
  // Parse the line
  val fields = line.split("\t");
  val id = fields(0)
  var (question, options) = fields(9) match {
    case Q4(question, a, b, c, d) => (question.trim(), List(a.trim(),b.trim(),c.trim(),d.trim()))
    case Q3(question, a, b, c) => (question.trim(), List(a.trim(),b.trim(),c.trim()))
    case Q2(question, a, b) => (question.trim(), List(a.trim(),b.trim()))
  }
  val answer = options(fields(3).trim() match {
    case "A" => 0
    case "B" => 1
    case "C" => 2
    case "D" => 3
  })
  val premises = new Document(fields(13)).sentences
  val statementTemplate = fields(14)
  val isTest = fields(11) match {
    case "0" => false
    case "NULL" => true
    case "1" => true
  }
  val isDev = fields(12) match {
    case "0" => false
    case "NULL" => false
    case "1" => true
  }
  if (isDev && !isTest) {
    throw new IllegalStateException("Dev that's not test?")
  }

  // Determine if we should be printing this example
  val doPrint = args(1).toLowerCase match {
    case "train" => !isDev && !isTest
    case "dev"   => isDev && isTest
    case "test"   => !isDev && isTest
  }
  
  // Print the example
  if (doPrint) {
    // Write the question
    println("#Q: " + question)
    if (premises.size > 1) {
      multiSentencePremises += 1
    }
    allQuestions += 1

    // Get coref target
    val questionSentence = new Sentence(question)
    val questionTree = questionSentence.dependencyGraph
    var canonicalMention:String = null
    val patterns = questionSentence.word(0).toLowerCase match {
      case "what" => SEMGREX_PATTERNS_WHAT_HOW
      case "how"  => SEMGREX_PATTERNS_WHAT_HOW
      case _      => SEMGREX_PATTERNS_OTHER
    }
    for ((takeFirst, pattern) <- patterns) {
      if (canonicalMention == null) {
        val m:SemgrexMatcher = pattern.matcher(questionTree);
        var argBest:IndexedWord = null
        var argBestAdj:IndexedWord = null
        var best:Int = if (takeFirst) 99999 else -1
        while (m.find()) {
          val target = m.getNode("target")
          if (target.word.toLowerCase != "which") {
            if ((takeFirst && target.index() < best) ||
                (!takeFirst && target.index() > best)) {
              best = target.index()
              argBest = target
              argBestAdj = m.getNode("adj")
            }
          }
        }
        if (argBest != null) {
          canonicalMention = (if (argBestAdj != null) argBestAdj.word + " " else "") + argBest.word
        }
      }
    }


    // Loop over possible answers
    for (focus <- options) {
      val statement = statementTemplate.replace("BLANK_", focus);
      val correct = (focus == answer)
      // Write the answer
      println("#A: " + focus)
      for (premise <- premises) {
        println(premise)
      }
      if (correct) {
        print("TRUE: ")
      } else {
        print("FALSE: ")
      }
      // Write the statement
      def resolveCoref(statement:String):String = {
        val rtn:String = (if (canonicalMention != null) {
          statement.replaceAll("It ", canonicalMention + " ")
        } else {
          statement
        }).trim
        if (!rtn.endsWith(".")) {
          rtn + " ."
        } else {
          rtn
        }
      }
      if (statement == "FAIL" || statement.trim == "*** generation failure ***") {
        if (focus.startsWith("It")) {
          println(resolveCoref(focus))
        } else {
          println(question.replace("?", "") + " " + resolveCoref(focus))
        }
      } else {
        println(resolveCoref(statement))
      }
      // Newline to signify a new example
      println()
    }
  }
}

System.err.println("" + multiSentencePremises + "/" + allQuestions + " questions have multiple premises")
