#!/bin/bash
exec scala -J-Xmx2g -classpath corenlp-scala.jar:${JAVANLP_HOME}/projects/core/classes:/u/nlp/data/StanfordCoreNLPModels/stanford-corenlp-models-current.jar "$0" "$@"
!#

/*
 * NOTE: You should make sure the following are in you classpath in the line above:
 *  - corenlp-scala.jar (git@github.com:gangeli/CoreNLP-Scala.git)
 *  - CoreNLP (http://nlp.stanford.edu/software/corenlp.shtml)
 *  - CoreNLP models
 */

import edu.stanford.nlp.Sentence

val AUXILLIARY_VERBS = Set[String](
    "be",
    "can",
    "could",
    "dare",
    "do",
    "have",
    "may",
    "might",
    "must",
    "need",
    "ought",
    "shall",
    "should",
    "will",
    "would"
  )

val QUANTIFIERS = Set[String](
	"all",
	"any",
	"both",
	"each",
	"every",
	"the lot of",
	"all of",
	"for all",
	"for every",
	"for each",
	"most",
	"many",
	"enough",
	"more than",
	"a lot of",
	"lot of",
	"plenty of",
	"heap of",
	"a load of",
	"load of",
	"ton of",
	"few",
	"several",
	"some",
	"either",
	"a",
	"the",
	"less than",
	"some of",
	"some of the",
	"one of",
	"one of the",
	"a few",
	"there be",
	"there exist",
	"there be some",
	"there be few",
	"no",
	"not",
	"not",
	"without",
	"neither",
	"none of",
	"at most"
)

def hackyHead(input:String, prefix:Char='N'):Option[String] = {
  val sentence = new Sentence(input)
  val seq = sentence.pos.zip(sentence.lemma)
  seq.takeWhile{ case (pos:String, lemma:String) => pos(0) != 'P' && pos != "IN" }
     .reverse
     .find{ case (pos:String, lemma:String) => pos(0) == prefix && pos(pos.length - 1) != 'P' && pos(pos.length - 1) != 'G' && !AUXILLIARY_VERBS(lemma) }
     .map{ _._2 };
}

for (line <- io.Source.stdin.getLines()) {
  if (line.length < 50) {
    val fields  = line.split("\t")
    if (fields.length >= 3) {
      for ( subj <- hackyHead(fields(0), 'N');
            rel  <- hackyHead(fields(1), 'V');
            obj  <- hackyHead(fields(2), 'N') ) {
        def quantifier(elem:String, head:String):String = {
          QUANTIFIERS.filter( (x:String) => elem.toLowerCase.startsWith(x + " ") ).headOption match {
            case Some(q) => if (head.startsWith(q) || q.startsWith(head)) "" else q + " "
            case None => ""
          }
        }
        println(quantifier(fields(0), subj) + subj + "\t" + rel + "\t" + quantifier(fields(2), obj) + obj)
      }
    }
  }
}
