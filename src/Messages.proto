
option java_package = "edu.stanford.nlp.naturalli";

/** An enumeration of monotonicity markings (upwards, downwards, or flat) */
enum Monotonicity {
  UP             = 0;
  DOWN           = 1;
  FLAT           = 2;
  ANY_OR_INVALID = 3;
}

/** 
 * An enumeration of inference states, in the collapsed set 
 * of {T,F,U}.
 */
enum CollapsedInferenceState {
  FALSE   = 0;
  TRUE    = 1;
  UNKNOWN = 2;
}

/** A single word in a fact */
message Word {
  required uint32 word               = 1;
  optional string gloss              = 2 [default = "unk"];
  optional Monotonicity monotonicity = 3 [default = FLAT];
  optional string pos                = 4 [default = "?"];
  optional uint32 sense              = 5 [default = 0];
}

/** A fact, potentially with a marked truth and confidence */
message Fact {
  repeated Word word               = 1;
  optional string gloss            = 2;
  optional string toString         = 3;
  optional uint32 monotoneBoundary = 4;
}

/** A query to the server; at minimum, it should contain
    the query fact, and the fact database to use */
message Query {
  required Fact   queryFact    = 1;
  required bool   useRealWorld = 2;
  repeated Fact   knownFact    = 3;
  optional uint64 timeout      = 4 [ default = 1000 ];
  optional Costs  costs        = 5;
  optional string searchType   = 6 [ default = "ucs" ];
  optional string cacheType    = 7 [ default = "none" ];
  optional bool   allowLookup  = 8 [ default = true ];

  optional uint32 id           = 50;
  optional bool   forceFalse   = 51;

  optional bool shutdownServer = 101 [ default = false ];
}

/** An inference, implementing a linked list of facts corresponding to a reverse inference */
message Inference {
  required Fact                    fact             = 1;
  optional Inference               impliedFrom      = 2;
  optional uint32                  incomingEdgeType = 3;

  optional double                  score            = 11;
  optional CollapsedInferenceState state            = 12;
  optional Monotonicity            monotoneContext  = 13;
  optional float                   incomingEdgeCost = 14;

  optional uint64                  ticks            = 21;
  optional string                  tag              = 22;
}

/** A response from the server, encoding a number of inferences and an optional error message */
message Response {
  repeated Inference inference    = 1;
  optional bool      error        = 2 [ default = false ];
  optional string    errorMessage = 3;
  optional uint64    totalTicks   = 4;
}

/** A holistic view of the weights to send to the search component */
message Costs {
  optional float bias = 1 [ default = 0.0 ];

  optional UnlexicalizedCosts unlexicalizedMonotoneUp   = 11;
  optional UnlexicalizedCosts unlexicalizedMonotoneDown = 12;
  optional UnlexicalizedCosts unlexicalizedMonotoneFlat = 13;
  optional UnlexicalizedCosts unlexicalizedMonotoneAny  = 14;
}


/** A set of (relatively) dense unlexicalized weights which can be passed back and forth to the server */
message UnlexicalizedCosts {
  /** There should be |edges| elements in this, according to the indices in EDGE_TYPE */
  repeated float trueCost     = 1;
  /** There should be |edges| elements in this, according to the indices in EDGE_TYPE */
  repeated float falseCost = 2;
}
